(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
const utils = require('../utils/index')

function generateRoot (options) {
    const root = {
        children: []
    }
    const attributes = options.attributes
    for (let key in attributes) {
        root[key] = utils[attributes[key].type](attributes[key].options)
    }
    return root
}

function generateNode (root, child) {
    const rand = utils.randomInt(root.children.length)
    if (rand === root.children.length) {
        root.children.push(child)
    } else {
        generateNode(root.children[rand], child)
    }
}

const DEFAULT_OPTIONS = {
    size: 10,
    attributes: {
        id: {
            type: 'uuid'
        },
        name: {
            type: 'randomString',
            options: {
                maxLength: 10,
            }
        }
    }
}

function randomTree (customizedOptions) {
    const options = Object.assign({}, DEFAULT_OPTIONS, customizedOptions)
    const root = generateRoot(options)
    for (let i = 0; i < options.size; i++) {
        generateNode(root, generateRoot(options))
    }
    return root
}

module.exports = randomTree

},{"../utils/index":3}],2:[function(require,module,exports){
const randomTree = require('./graphs/random-tree')
const utils = require('./utils/index')

const res = Object.assign({
    randomTree,
}, utils)

module.exports = res

},{"./graphs/random-tree":1,"./utils/index":3}],3:[function(require,module,exports){
module.exports = {
    randomCharFromCategories: require('./random-char-from-categories'),
    randomChinese: require('./random-chinese'),
    randomFromArray: require('./random-from-array'),
    randomFromRange: require('./random-from-range'),
    randomInt: require('./random-int'),
    randomJapanese: require('./random-japanese'),
    randomLetter: require('./random-letter'),
    randomNumber: require('./random-number'),
    randomSpecial: require('./random-special'),
    randomString: require('./random-string'),
    uuid: require('./uuid'),
}

},{"./random-char-from-categories":4,"./random-chinese":5,"./random-from-array":6,"./random-from-range":7,"./random-int":8,"./random-japanese":9,"./random-letter":10,"./random-number":11,"./random-special":12,"./random-string":13,"./uuid":14}],4:[function(require,module,exports){
const randomFromArray = require('./random-from-array')
const randomByCats = {
    chinese: require('./random-chinese'),
    japanese: require('./random-japanese'),
    letter: require('./random-letter'),
    number: require('./random-number'),
    special: require('./random-special'),
}

module.exports = (cats) => {
    const cat = randomFromArray(cats)
    return randomByCats[cat]()
}

},{"./random-chinese":5,"./random-from-array":6,"./random-japanese":9,"./random-letter":10,"./random-number":11,"./random-special":12}],5:[function(require,module,exports){
const randomFromRange = require('./random-from-range')

const range = {
    start: 0x4E00,
    end: 0x9FA5
}

module.exports = () => String.fromCharCode(randomFromRange(range.start, range.end))

},{"./random-from-range":7}],6:[function(require,module,exports){
const randomInt = require('./random-int')

module.exports = arr => {
    if (!Array.isArray(arr) || !arr.length) {
        return null
    }
    return arr[randomInt(arr.length - 1)]
}

},{"./random-int":8}],7:[function(require,module,exports){
const randomInt = require('./random-int')

module.exports = (start, end) => start + randomInt(end - start)

},{"./random-int":8}],8:[function(require,module,exports){
module.exports = (n) => Math.round(Math.random() * n)

},{}],9:[function(require,module,exports){
const randomFromArray = require('./random-from-array')
const randomFromRange = require('./random-from-range')

const ranges = [
    {
        start: 0x3040,
        end: 0x309F
    },
    {
        start: 0x30A0,
        end: 0x30FF
    }
]

module.exports = () => {
    const range = randomFromArray(ranges)
    return String.fromCharCode(randomFromRange(range.start, range.end))
}

},{"./random-from-array":6,"./random-from-range":7}],10:[function(require,module,exports){

const randomFromArray = require('./random-from-array')

const letters = 'abcdefghijklmnopqrstuvwxyz'.split('')

module.exports = () => randomFromArray(letters)

},{"./random-from-array":6}],11:[function(require,module,exports){
const randomFromArray = require('./random-from-array')

const numbers = '0123456789'.split('')

module.exports = () => randomFromArray(numbers)

},{"./random-from-array":6}],12:[function(require,module,exports){
const randomFromArray = require('./random-from-array')

const specialChars = '!$%^&*()_+|~-=`{}[]:;<>?,./'.split('')

module.exports = () => randomFromArray(specialChars)

},{"./random-from-array":6}],13:[function(require,module,exports){
const randomCharFromCats = require('./random-char-from-categories')
const randomFromRange = require('./random-from-range')

const DEFAULT_OPTIONS = {
    length: 6,
    maxLength: 6,
    capitalization: 'lowercase', // lowercase, uppercase
    categories: [
        // 'number',
        'letter', // default
        // 'special',
        // 'chinese',
        // 'japanese',
    ]
}

module.exports = (customizedOptions) => {
    const options = Object.assign({}, DEFAULT_OPTIONS, customizedOptions)
    let res = ''
    const len = options.length ? options.length : randomFromRange(1, options.maxLength)
    for (let i = 0; i < len; i ++) {
        res += randomCharFromCats(options.categories)
    }
    if (options.capitalization === 'uppercase') {
        res = res.toUpperCase()
    }
    return res
}
},{"./random-char-from-categories":4,"./random-from-range":7}],14:[function(require,module,exports){
module.exports = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random()*16|0
    const v = c === 'x' ? r : (r&0x3|0x8)
    return v.toString(16)
})

},{}],15:[function(require,module,exports){
// get successful control from form and assemble into object
// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2

// types which indicate a submit action and are not successful controls
// these will be ignored
var k_r_submitter = /^(?:submit|button|image|reset|file)$/i;

// node names which could be successful controls
var k_r_success_contrls = /^(?:input|select|textarea|keygen)/i;

// Matches bracket notation.
var brackets = /(\[[^\[\]]*\])/g;

// serializes form fields
// @param form MUST be an HTMLForm element
// @param options is an optional argument to configure the serialization. Default output
// with no options specified is a url encoded string
//    - hash: [true | false] Configure the output type. If true, the output will
//    be a js object.
//    - serializer: [function] Optional serializer function to override the default one.
//    The function takes 3 arguments (result, key, value) and should return new result
//    hash and url encoded str serializers are provided with this module
//    - disabled: [true | false]. If true serialize disabled fields.
//    - empty: [true | false]. If true serialize empty fields
function serialize(form, options) {
    if (typeof options != 'object') {
        options = { hash: !!options };
    }
    else if (options.hash === undefined) {
        options.hash = true;
    }

    var result = (options.hash) ? {} : '';
    var serializer = options.serializer || ((options.hash) ? hash_serializer : str_serialize);

    var elements = form && form.elements ? form.elements : [];

    //Object store each radio and set if it's empty or not
    var radio_store = Object.create(null);

    for (var i=0 ; i<elements.length ; ++i) {
        var element = elements[i];

        // ingore disabled fields
        if ((!options.disabled && element.disabled) || !element.name) {
            continue;
        }
        // ignore anyhting that is not considered a success field
        if (!k_r_success_contrls.test(element.nodeName) ||
            k_r_submitter.test(element.type)) {
            continue;
        }

        var key = element.name;
        var val = element.value;

        // we can't just use element.value for checkboxes cause some browsers lie to us
        // they say "on" for value when the box isn't checked
        if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {
            val = undefined;
        }

        // If we want empty elements
        if (options.empty) {
            // for checkbox
            if (element.type === 'checkbox' && !element.checked) {
                val = '';
            }

            // for radio
            if (element.type === 'radio') {
                if (!radio_store[element.name] && !element.checked) {
                    radio_store[element.name] = false;
                }
                else if (element.checked) {
                    radio_store[element.name] = true;
                }
            }

            // if options empty is true, continue only if its radio
            if (!val && element.type == 'radio') {
                continue;
            }
        }
        else {
            // value-less fields are ignored unless options.empty is true
            if (!val) {
                continue;
            }
        }

        // multi select boxes
        if (element.type === 'select-multiple') {
            val = [];

            var selectOptions = element.options;
            var isSelectedOptions = false;
            for (var j=0 ; j<selectOptions.length ; ++j) {
                var option = selectOptions[j];
                var allowedEmpty = options.empty && !option.value;
                var hasValue = (option.value || allowedEmpty);
                if (option.selected && hasValue) {
                    isSelectedOptions = true;

                    // If using a hash serializer be sure to add the
                    // correct notation for an array in the multi-select
                    // context. Here the name attribute on the select element
                    // might be missing the trailing bracket pair. Both names
                    // "foo" and "foo[]" should be arrays.
                    if (options.hash && key.slice(key.length - 2) !== '[]') {
                        result = serializer(result, key + '[]', option.value);
                    }
                    else {
                        result = serializer(result, key, option.value);
                    }
                }
            }

            // Serialize if no selected options and options.empty is true
            if (!isSelectedOptions && options.empty) {
                result = serializer(result, key, '');
            }

            continue;
        }

        result = serializer(result, key, val);
    }

    // Check for all empty radio buttons and serialize them with key=""
    if (options.empty) {
        for (var key in radio_store) {
            if (!radio_store[key]) {
                result = serializer(result, key, '');
            }
        }
    }

    return result;
}

function parse_keys(string) {
    var keys = [];
    var prefix = /^([^\[\]]*)/;
    var children = new RegExp(brackets);
    var match = prefix.exec(string);

    if (match[1]) {
        keys.push(match[1]);
    }

    while ((match = children.exec(string)) !== null) {
        keys.push(match[1]);
    }

    return keys;
}

function hash_assign(result, keys, value) {
    if (keys.length === 0) {
        result = value;
        return result;
    }

    var key = keys.shift();
    var between = key.match(/^\[(.+?)\]$/);

    if (key === '[]') {
        result = result || [];

        if (Array.isArray(result)) {
            result.push(hash_assign(null, keys, value));
        }
        else {
            // This might be the result of bad name attributes like "[][foo]",
            // in this case the original `result` object will already be
            // assigned to an object literal. Rather than coerce the object to
            // an array, or cause an exception the attribute "_values" is
            // assigned as an array.
            result._values = result._values || [];
            result._values.push(hash_assign(null, keys, value));
        }

        return result;
    }

    // Key is an attribute name and can be assigned directly.
    if (!between) {
        result[key] = hash_assign(result[key], keys, value);
    }
    else {
        var string = between[1];
        // +var converts the variable into a number
        // better than parseInt because it doesn't truncate away trailing
        // letters and actually fails if whole thing is not a number
        var index = +string;

        // If the characters between the brackets is not a number it is an
        // attribute name and can be assigned directly.
        if (isNaN(index)) {
            result = result || {};
            result[string] = hash_assign(result[string], keys, value);
        }
        else {
            result = result || [];
            result[index] = hash_assign(result[index], keys, value);
        }
    }

    return result;
}

// Object/hash encoding serializer.
function hash_serializer(result, key, value) {
    var matches = key.match(brackets);

    // Has brackets? Use the recursive assignment function to walk the keys,
    // construct any missing objects in the result tree and make the assignment
    // at the end of the chain.
    if (matches) {
        var keys = parse_keys(key);
        hash_assign(result, keys, value);
    }
    else {
        // Non bracket notation can make assignments directly.
        var existing = result[key];

        // If the value has been assigned already (for instance when a radio and
        // a checkbox have the same name attribute) convert the previous value
        // into an array before pushing into it.
        //
        // NOTE: If this requirement were removed all hash creation and
        // assignment could go through `hash_assign`.
        if (existing) {
            if (!Array.isArray(existing)) {
                result[key] = [ existing ];
            }

            result[key].push(value);
        }
        else {
            result[key] = value;
        }
    }

    return result;
}

// urlform encoding serializer
function str_serialize(result, key, value) {
    // encode newlines as \r\n cause the html spec says so
    value = value.replace(/(\r)?\n/g, '\r\n');
    value = encodeURIComponent(value);

    // spaces should be '+' rather than '%20'.
    value = value.replace(/%20/g, '+');
    return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;
}

module.exports = serialize;

},{}],16:[function(require,module,exports){
module.exports = options => {
  var treeSize = options.treeSize
  var layoutType = options.layoutType
  var direction = options.direction
  var hgap = options.hgap
  var vgap = options.vgap
  delete options.treeSize
  delete options.layoutType
  delete options.hgap
  delete options.vgap
  return `var G6 = require('@ali/g6');
// 详细文档见 ： https://antv.alipay.com/g6/doc/index.html
var randomGraph = require('random-graph/dist/randomGraph');

var randomTree = randomGraph.randomTree; // 创建随机树
var Util = G6.Util; // G6 Utils

var PEM = 18;
var treeData = randomTree({
  size: ${treeSize},
  attributes: {
    name: {
      type: 'randomString',
      options: {
        length: 0,
        maxLength: 16,
        categories: [
          // 'japanese',
          'letter',
          // 'chinese',
        ]
      }
    }
  }
});

// 准备布局配置
var layoutCfg = ${JSON.stringify(options, null, 2)}; 
${(layoutType === 'CompactBoxTree' || layoutType === 'IndentedTree') ? `layoutCfg.getHGap = function(d) {
  return ${hgap / 2};
};
layoutCfg.getVGap = function(d) {
  return ${vgap / 2};
};` : `// 自定义树节点
var DEFAULT_NODE_SIZE = 5;
G6.registNode('treeNode', {
  draw(cfg, group) {
    var origin = cfg.origin;
    var r = layoutCfg.nodeSize ? layoutCfg.nodeSize / 2 : DEFAULT_NODE_SIZE;
    var shapeCfg = {
      attrs: {
        x: cfg.x,
        y: cfg.y,
        r: r,
        stroke: '#999',
        fill: 'white',
        fillOpacity: 1,
      },
    };
    if (origin.children && origin.children.length) {
      shapeCfg.class = origin.isCollapsed ? 'spreadoutButton' : 'collapseButton';
    }
    return group.addShape('circle', shapeCfg);
  },
  afterDraw(cfg, group) {
    var origin = cfg.origin;
    var r = layoutCfg.nodeSize ? layoutCfg.nodeSize / 2 : DEFAULT_NODE_SIZE;
    var align = origin.align;
    var labelAttrs = {
      text: origin.name,
      fill: '#666',
      textBaseline: 'middle',
      x: cfg.x + r + DEFAULT_NODE_SIZE,
      y: cfg.y,
      textAlign: 'left',
    };
    if (align === 'R') {
      Util.mix(labelAttrs, {
        x: cfg.x - r - DEFAULT_NODE_SIZE,
        y: cfg.y,
        textAlign: 'right',
      });
    } else if (align === 'T' || align === 'CH') {
      Util.mix(labelAttrs, {
        x: cfg.x,
        y: cfg.y + r + DEFAULT_NODE_SIZE,
        textAlign: 'right',
        rotate: -Math.PI / 2,
      });
    } else if (align === 'B') {
      Util.mix(labelAttrs, {
        x: cfg.x,
        y: cfg.y - r - DEFAULT_NODE_SIZE,
        textAlign: 'left',
        rotate: -Math.PI / 2,
      });
    }
    var label = group.addShape('text', {
      attrs: labelAttrs,
    });
    return label;
  }
});`}
    
// 生成树图实例
var tree = new G6.Tree({
  id: 'mountNode',     // 容器ID
  layoutCfg,           // 布局配置
  forceFit: true,      // 宽度自适应
  fitView: 'autoZoom', // 自动缩放
  showButton: ${layoutType === 'CompactBoxTree' || layoutType === 'IndentedTree' ? 'true' : 'false'},
  height: 600,     // 画布高
  layoutFn: G6.Layout.${layoutType}, // 布局类型
});

// 加载数据
tree.source(treeData);

${(layoutType === 'CompactBoxTree' || layoutType === 'IndentedTree') ?
`tree.node()
  .label('name', name => name)
  .style({
    fillOpacity: 1
  });` : `tree.node().shape('treeNode');`
}
${
    (function () {
      var HORIZONTAL_DIRECTIONS = [
        'L',
        'R',
        'LR',
        'RL',
        'H',
      ];
      if (layoutType === 'Dendrogram') {
        return HORIZONTAL_DIRECTIONS.indexOf(direction) > -1 ?
          `tree.edge().shape('VH');` : `tree.edge().shape('HV');`
      } else if (layoutType === 'IndentedTree') {
        return `tree.edge().shape('VH');`
      } else {
        return `tree.edge().shape('smooth');`
      }
    })()
}

// 渲染树图
tree.render();`
}

},{}],17:[function(require,module,exports){
const serialize = require('form-serialize')
const {
  randomTree
} = require('random-graph')
const codeTemplate = require('./tree-layout-code-template');

const PEM = 18;
const DEFAULT_NODE_SIZE = 5
const LAYOUTS = [
  'CompactBoxTree',
  'Dendrogram',
  'IndentedTree',
  'LayeredTidyTree',
];
const DIRECTIONS = [
  'LR',
  'RL',
  'TB',
  'BT',
  'H',
  'V'
]
const HORIZONTAL_DIRECTIONS = [
  'L',
  'R',
  'LR',
  'RL',
  'H',
]

function tmplDirectionsByLayout(layout) {
  let directions
  if (layout === LAYOUTS[2]) {
    directions = [
      DIRECTIONS[0],
      DIRECTIONS[1],
      DIRECTIONS[4]
    ]
  } else {
    directions = DIRECTIONS
  }
  return `${
    directions
      .map(direction => `<option value="${direction}">${direction}</option>`)
      .join('')
    }`
}

function tmplPropsByLayout(layout) {
  if (layout === LAYOUTS[0] || layout === LAYOUTS[4]) {
    return formItemsByMeta([
      {
        name: 'hgap'
      },
      {
        name: 'vgap'
      }
    ])
  }
  if (layout === LAYOUTS[1]) {
    return formItemsByMeta([
      {
        name: 'nodeSep'
      },
      {
        name: 'nodeSize'
      },
      {
        name: 'rankSep',
        value: 200
      },
      // {
      //   name: 'subTreeSep'
      // }
    ])
  }
  if (layout === LAYOUTS[2]) {
    return formItemsByMeta([
      {
        name: 'indent'
      },
      {
        name: 'vgap',
        min: 0
      }
    ])
  }
  if (layout === LAYOUTS[3]) {
    return formItemsByMeta([
      {
        name: 'nodeSep'
      },
      {
        name: 'nodeSize'
      },
      {
        name: 'rankSep',
        value: 200
      }
    ])
  }
}

const generateRandomTree = size => randomTree({
  size: size - 1,
  attributes: {
    id: {
      type: 'uuid'
    },
    name: {
      type: 'randomString',
      options: {
        length: 0,
        maxLength: 16,
        categories: [
          // 'japanese'
          'letter',
          // 'chinese',
          // 'special'
        ]
      }
    }
  }
})

const hasKey = (obj, key) => ({}.hasOwnProperty.call(obj, key))

function formItemsByMeta(arr) {
  return `${arr.map(item => {
      const props = Object.assign({
        min: 10,
        max: 200,
        value: 20
      }, item)
      return `<label class="form-label">${props.name}</label>
<input name="${props.name}" class="form-item" type="range"
 min="${props.min}" max="${props.max}" value="${props.value}"/>`
    }
  ).join('')}`
}

// dom elements
const $layoutProps = $('#layout-props');
const $layoutType = $('#layout-type');
const $direction = $('#direction');
const $propsContainer = $('#props-container');
const $canvasContainer = $('#canvas-container');
const $code = $('#code');
$layoutType.html(
  LAYOUTS.map(function (layout) {
    return '<option value="' + layout + '">' + layout + '</option>';
  }).join('')
)
$layoutType.on('change', () => {
  renderDirectionsAndProps()
});
$layoutProps.on('change', () => {
  render();
});
// $(window).on('resize', () => {
//   render();
// });

// fulfil props
function renderDirectionsAndProps() {
  const layout = $layoutType.val();
  $direction.html(tmplDirectionsByLayout(layout))
  $propsContainer.html(tmplPropsByLayout(layout))
}

function getProps() {
  const props = serialize($layoutProps[0], {
    hash: true
  })
  for (let key in props) {
    const numeric = parseInt(props[key], 10)
    if (!isNaN(numeric)) {
      props[key] = numeric
    }
  }
  return props
}

let tree = null

// render graph
function render() {
  if (tree) {
    tree.destroy()
  }
  const options = getProps()
  // drawing
  const treeData = generateRandomTree(options.treeSize)
  const layoutFn = G6.Layout[options.layoutType]
  const layoutCfg = Object.assign({
    getHGap (d) {
      if (d.isRoot) {
        return (hasKey(options, 'hgap') ? options.hgap : PEM) * 2
      }
      return (hasKey(options, 'hgap') ? options.hgap : PEM) / 2
    },
    getVGap (d) {
      if (d.isRoot) {
        return (hasKey(options, 'vgap') ? options.vgap : PEM) * 2
      }
      return (hasKey(options, 'vgap') ? options.vgap : PEM) / 2
    }
  }, options)

  tree = new G6.Tree({
    id: 'canvas-container', // 容器ID
    forceFit: true,         // 宽度自适应
    fitView: 'autoZoom',    // 自动缩放
    // 展开收缩按钮
    showButton: options.layoutType === 'CompactBoxTree' || options.layoutType === 'IndentedTree',
    height: $canvasContainer.height(), // 画布高
    layoutCfg,
    layoutFn,
  });
  tree.source(treeData);
  if (options.layoutType === 'CompactBoxTree' || options.layoutType === 'IndentedTree') {
    tree.node()
      .label('name', name => name)
      .style({
        fillOpacity: 1
      })
  } else {
    G6.registNode('treeNode', {
      draw(cfg, group) {
        const origin = cfg.origin;
        const r = layoutCfg.nodeSize ? layoutCfg.nodeSize / 2 : DEFAULT_NODE_SIZE;
        const shapeAttrs = {
          attrs: {
            x: cfg.x,
            y: cfg.y,
            r,
            stroke: '#999',
            fill: 'white',
            fillOpacity: 1,
          },
        };
        if (origin.children && origin.children.length) {
          shapeAttrs.class = origin.isCollapsed ? 'spreadoutButton' : 'collapseButton';
        }
        return group.addShape('circle', shapeAttrs);
      },
      afterDraw(cfg, group) {
        const origin = cfg.origin
        const r = options.nodeSize ? options.nodeSize / 2 : DEFAULT_NODE_SIZE
        const align = origin.align
        const labelAttrs = {
          text: origin.name,
          fill: '#666',
          textBaseline: 'middle',
          x: cfg.x + r + DEFAULT_NODE_SIZE,
          y: cfg.y,
          textAlign: 'left',
        }
        if (align === 'R') {
          Object.assign(labelAttrs, {
            x: cfg.x - r - DEFAULT_NODE_SIZE,
            y: cfg.y,
            textAlign: 'right',
          })
        } else if (align === 'T' || align === 'CH') {
          Object.assign(labelAttrs, {
            x: cfg.x,
            y: cfg.y + r + DEFAULT_NODE_SIZE,
            textAlign: 'right',
            rotate: -Math.PI / 2,
          })
        } else if (align === 'B') {
          Object.assign(labelAttrs, {
            x: cfg.x,
            y: cfg.y - r - DEFAULT_NODE_SIZE,
            textAlign: 'left',
            rotate: -Math.PI / 2,
          })
        }
        const label = group.addShape('text', {
          attrs: labelAttrs,
        })
        return label
      }
    });
    tree.node().shape('treeNode')
  }
  if (options.layoutType === 'Dendrogram') {
    tree.edge().shape(HORIZONTAL_DIRECTIONS.indexOf(options.direction) > -1 ? 'VH' : 'HV');
  } else if (options.layoutType === 'IndentedTree') {
    tree.edge().shape('VH');
  } else {
    tree.edge().shape('smooth');
  }
  tree.render();
  const code = codeTemplate(options)
  $code.val(code);
  console.log(tree)
}

renderDirectionsAndProps()
render()

},{"./tree-layout-code-template":16,"form-serialize":15,"random-graph":2}]},{},[17]);
